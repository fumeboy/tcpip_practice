package main

func CheckSum16(b []byte, n int, init uint32) uint16 {
	/*
		发送数据时
			1、把校验和字段设置为0
			2、把需要校验的数据看成以16位为单位的数字组成，依次进行二进制反码求和。剩余不足 16 位，末尾补0
			3、把得到的结果 N 存入校验和字段中
		接收数据时
			1、把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段的值 N
			2、检查计算出的校验和的结果是否为0
			3、如果等于0，说明被整除，校验和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包

		校验原理， N + N反 = 1111 1111 1111 1111， 再取反，即为 0

		上述中， “依次进行二进制反码求和”，和 “先求和，最终结果取反” 是一样的
	*/

	sum := init
	for i := 0; i < n-1; i += 2 { // 对每 16 位求和
		sum += uint32(b[i])<<8 | uint32(b[i+1])
	}
	if n&1 != 0 { // n 为奇数说明会有剩余的 8 位
		sum += uint32(b[n-1]) << 8
	}
	for (sum >> 16) > 0 { // 若相加后最高位有进位，那么不能舍弃，加到低位
		sum = (sum & 0xffff) + (sum >> 16)
	}
	return ^(uint16(sum)) // 取反. 使用反码可以保证 无论是 大端还是小端， 计算的结果都是一致的
}
